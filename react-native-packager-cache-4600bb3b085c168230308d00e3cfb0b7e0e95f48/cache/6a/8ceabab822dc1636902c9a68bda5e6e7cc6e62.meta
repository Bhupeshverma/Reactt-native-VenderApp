["29e26fdb5fcadbd1abcfbbe791a0babb722f9cb6","b16c5e69c0830424ce60d2ecf3ce30892bd5b32c",["react","react-native","lodash","@shoutem/theme","../../index","./Page"],[144,241,281,375,416,453],{"version":3,"sources":["/home/ziddi/Desktop/Bhupesh/venders/node_modules/@shoutem/ui/components/HorizontalPager/HorizontalPager.js"],"names":["HorizontalPager","props","state","width","height","selectedIndex","initialSelectedIndex","pageMargin","showNextPage","shouldRenderContent","scrolledToInitialIndex","onHorizontalScroll","bind","onLayoutContainer","onScrollViewRef","runAfterInteractions","easeInEaseOut","setState","nextProps","scrollEnabled","scrollToPage","event","nativeEvent","layout","requestAnimationFrame","scrollToInitialPage","onIndexSelected","contentOffset","newSelectedIndex","calculateIndex","isFunction","scroller","style","nextPageInsetSize","page","scrollTo","x","calculateContainerWidth","animated","data","length","Math","round","index","surroundingPagesToLoad","minPageIndex","maxPageIndex","renderPage","pages","map","pageData","pageIndex","lastPage","containerWidth","pageWidth","isPageActive","pageContent","shouldRenderPage","renderOverlay","bounces","renderPlaceholder","container","scrollView","renderPages","propTypes","bool","arrayOf","object","isRequired","func","number","defaultProps","StyledHorizontalPager"],"mappings":";;;;;;;AAAA;;;;AAKA;;AAMA;;;;AAEA;;AAEA;;AAIA;;IAaMA,e;;;AA8CJ,2BAAYC,KAAZ,EAAmB;AAAA;;AAAA,8IACXA,KADW;;AAEjB,UAAKC,KAAL,GAAa;AACXC,aAAO,CADI;AAEXC,cAAQ,CAFG;AAGXC,qBAAe,MAAKJ,KAAL,CAAWI,aAHf;AAIXC,4BAAsB,MAAKL,KAAL,CAAWI,aAJtB;AAKXE,kBAAY,MAAKN,KAAL,CAAWM,UALZ;AAMXC,oBAAc,MAAKP,KAAL,CAAWO,YANd;AAOXC,2BAAqB,KAPV;AAQXC,8BAAwB;AARb,KAAb;AAUA,UAAKC,kBAAL,GAA0B,MAAKA,kBAAL,CAAwBC,IAAxB,OAA1B;AACA,UAAKC,iBAAL,GAAyB,MAAKA,iBAAL,CAAuBD,IAAvB,OAAzB;AACA,UAAKE,eAAL,GAAuB,MAAKA,eAAL,CAAqBF,IAArB,OAAvB;AAdiB;AAelB;;;;wCAEmB;AAAA;;AAClB,sCAAmBG,oBAAnB,CAAwC,YAAM;AAC5C,qCAAgBC,aAAhB;AACA,eAAKC,QAAL,CAAc,EAAER,qBAAqB,IAAvB,EAAd;AACD,OAHD;AAID;;;8CAEyBS,S,EAAW;AAAA,UAC3Bb,aAD2B,GACT,KAAKH,KADI,CAC3BG,aAD2B;;;AAGnC,UAAI,KAAKJ,KAAL,CAAWkB,aAAX,IAA4B,CAACD,UAAUC,aAA3C,EAA0D;AACxD,aAAKC,YAAL,CAAkBf,aAAlB;AACD;AACF;;;sCAEiBgB,K,EAAO;AAAA;;AAAA,kCACGA,MAAMC,WAAN,CAAkBC,MADrB;AAAA,UACfpB,KADe,yBACfA,KADe;AAAA,UACRC,MADQ,yBACRA,MADQ;AAAA,UAEfM,sBAFe,GAEY,KAAKR,KAFjB,CAEfQ,sBAFe;;;AAIvB,UAAK,KAAKR,KAAL,CAAWC,KAAX,KAAqBA,KAAtB,IAAiC,KAAKD,KAAL,CAAWE,MAAX,KAAsBA,MAA3D,EAAoE;AAClE;AACD;;AAED,WAAKa,QAAL,CAAc,EAAEd,YAAF,EAASC,cAAT,EAAd,EAAiC,YAAM;AAGrC,YAAI,CAACM,sBAAL,EAA6B;AAC3Bc,gCAAsB;AAAA,mBAAM,OAAKC,mBAAL,EAAN;AAAA,WAAtB;AACD;AACF,OAND;AAOD;;;uCAEkBJ,K,EAAO;AAAA,UAChBhB,aADgB,GACE,KAAKH,KADP,CAChBG,aADgB;AAAA,UAEhBqB,eAFgB,GAEI,KAAKzB,KAFT,CAEhByB,eAFgB;;AAGxB,UAAMC,gBAAgBN,MAAMC,WAAN,CAAkBK,aAAxC;;AAEA,UAAMC,mBAAmB,KAAKC,cAAL,CAAoBF,aAApB,CAAzB;AACA,UAAItB,kBAAkBuB,gBAAtB,EAAwC;AAEtC;AACD;;AAGD,UAAIvB,kBAAkBuB,gBAAtB,EAAwC;AACtC,aAAKX,QAAL,CAAc;AACZZ,yBAAeuB;AADH,SAAd,EAEG,YAAM;AACP,cAAI,iBAAEE,UAAF,CAAaJ,eAAb,CAAJ,EAAmC;AACjCA,4BAAgBE,gBAAhB;AACD;AACF,SAND;AAOD;AACF;;;oCAEeG,Q,EAAU;AACxB,WAAKA,QAAL,GAAgBA,QAAhB;AACD;;;8CAEyB;AAAA,UAChBC,KADgB,GACN,KAAK/B,KADC,CAChB+B,KADgB;AAAA,mBAEoB,KAAK9B,KAFzB;AAAA,UAEhBC,KAFgB,UAEhBA,KAFgB;AAAA,UAETI,UAFS,UAETA,UAFS;AAAA,UAEGC,YAFH,UAEGA,YAFH;;AAQxB,aAAOA,eAAgBL,QAAQ6B,MAAMC,iBAA9B,GAAoD9B,QAAQI,UAAnE;AACD;;;iCAEY2B,I,EAAM;AAAA,UACT/B,KADS,GACC,KAAKD,KADN,CACTC,KADS;;;AAGjB,UAAI,KAAK4B,QAAL,IAAiB5B,KAAjB,IAA0B+B,IAA9B,EAAoC;AAClC,aAAKH,QAAL,CAAcI,QAAd,CAAuB;AACrBC,aAAGF,OAAO,KAAKG,uBAAL,EADW;AAErBC,oBAAU;AAFW,SAAvB;AAID;AACF;;;0CAEqB;AAAA,UACZZ,eADY,GACQ,KAAKzB,KADb,CACZyB,eADY;AAAA,UAEZpB,oBAFY,GAEa,KAAKJ,KAFlB,CAEZI,oBAFY;;;AAIpB,WAAKc,YAAL,CAAkBd,oBAAlB;AACA,WAAKW,QAAL,CAAc;AACZZ,uBAAeC,oBADH;AAEZI,gCAAwB;AAFZ,OAAd,EAGG,YAAM;AACP,YAAI,iBAAEoB,UAAF,CAAaJ,eAAb,CAAJ,EAAmC;AACjCA,0BAAgBpB,oBAAhB;AACD;AACF,OAPD;AAQD;;;mCAEcqB,a,EAAe;AAAA,oBACiB,KAAKzB,KADtB;AAAA,UACpBC,KADoB,WACpBA,KADoB;AAAA,UACbE,aADa,WACbA,aADa;AAAA,UACEE,UADF,WACEA,UADF;AAAA,UAEpBgC,IAFoB,GAEX,KAAKtC,KAFM,CAEpBsC,IAFoB;;;AAI5B,UAAIX,mBAAmBvB,aAAvB;;AAEA,UAAIsB,cAAcS,CAAd,IAAmB,CAAvB,EAA0B;AACxBR,2BAAmB,CAAnB;AACD;;AAED,UAAIvB,iBAAiBkC,KAAKC,MAAL,GAAc,CAAnC,EAAsC;AACpCZ,2BAAmBW,KAAKC,MAAL,GAAc,CAAjC;AACD;;AAED,UAAIrC,SAASwB,cAAcS,CAAd,GAAkB,CAA/B,EAAkC;AAChCR,2BAAmBa,KAAKC,KAAL,CAAWf,cAAcS,CAAd,IAAmBjC,QAAQI,UAA3B,CAAX,CAAnB;AACD;AACD,aAAOqB,gBAAP;AACD;;;qCAEgBe,K,EAAO;AAAA,mBACmB,KAAK1C,KADxB;AAAA,UACdsC,IADc,UACdA,IADc;AAAA,UACRK,sBADQ,UACRA,sBADQ;AAAA,UAEdvC,aAFc,GAEI,KAAKH,KAFT,CAEdG,aAFc;;AAKtB,UAAMwC,eAAgBxC,iBAAiBuC,sBAAlB,GACnB,CADmB,GACfvC,gBAAgBuC,sBADtB;;AAGA,UAAME,eAAgBzC,iBAAkBkC,KAAKC,MAAL,GAAcI,sBAAd,GAAuC,CAA1D,GACnBL,KAAKC,MAAL,GAAc,CADK,GACDnC,gBAAgBuC,sBADpC;;AAGA,aAAQD,SAASE,YAAV,IAA4BF,SAASG,YAA5C;AACD;;;kCAEa;AAAA;;AAAA,oBACuD,KAAK5C,KAD5D;AAAA,UACJC,KADI,WACJA,KADI;AAAA,UACGC,MADH,WACGA,MADH;AAAA,UACWG,UADX,WACWA,UADX;AAAA,UACuBC,YADvB,WACuBA,YADvB;AAAA,UACqCH,aADrC,WACqCA,aADrC;AAAA,oBAEwB,KAAKJ,KAF7B;AAAA,UAEJsC,IAFI,WAEJA,IAFI;AAAA,UAEEQ,UAFF,WAEEA,UAFF;AAAA,UAEcf,KAFd,WAEcA,KAFd;;;AAIZ,UAAMgB,QAAQT,KAAKU,GAAL,CAAS,UAACC,QAAD,EAAWC,SAAX,EAAyB;AAC9C,YAAMC,WAAWD,cAAcZ,KAAKC,MAAL,GAAc,CAA7C;AACA,YAAMa,iBAAiB,OAAKhB,uBAAL,EAAvB;AACA,YAAIiB,YAAYnD,KAAhB;;AAEA,YAAIK,gBAAgB,CAAC4C,QAArB,EAA+B;AAI7BE,sBAAYnD,QAAQI,UAAR,GAAqByB,MAAMC,iBAAvC;AACD;;AAGD,YAAI,CAACoB,cAAL,EAAqB,OAAO,IAAP;;AAErB,YAAME,eAAgBlD,kBAAkB8C,SAAxC;AACA,YAAMK,cAAc,OAAKC,gBAAL,CAAsBN,SAAtB,KAClB;AAAA;AAAA;AACE,sBAAUI,YADZ;AAEE,mBAAOD,SAFT;AAGE,mBAAOtB,MAAME;AAHf;AAKGa,qBAAWG,QAAX,EAAqBC,SAArB,EAAgC,EAAEhD,YAAF,EAASC,cAAT,EAAhC;AALH,SADF;;AAUA,eACE;AAAA;AAAA,YAAM,KAAK+C,SAAX,EAAsB,OAAO,EAAEhD,OAAOkD,cAAT,EAA7B;AACGG;AADH,SADF;AAKD,OA/Ba,CAAd;AAgCA,aAAOR,KAAP;AACD;;;oCAEe;AAAA,oBACkB,KAAK/C,KADvB;AAAA,UACNyD,aADM,WACNA,aADM;AAAA,UACSnB,IADT,WACSA,IADT;AAAA,UAENlC,aAFM,GAEY,KAAKH,KAFjB,CAENG,aAFM;;;AAId,UAAI,iBAAEyB,UAAF,CAAa4B,aAAb,CAAJ,EAAiC;AAC/B,eAAOA,cAAcnB,IAAd,EAAoBlC,aAApB,CAAP;AACD;;AAED,aAAO,IAAP;AACD;;;6BAEQ;AAAA,oBACsD,KAAKJ,KAD3D;AAAA,UACC0D,OADD,WACCA,OADD;AAAA,UACUxC,aADV,WACUA,aADV;AAAA,UACyBa,KADzB,WACyBA,KADzB;AAAA,UACgC4B,iBADhC,WACgCA,iBADhC;AAAA,UAECnD,mBAFD,GAEyB,KAAKP,KAF9B,CAECO,mBAFD;;;AAIP,UAAI,CAACA,mBAAL,EAA0B;AACxB,YAAI,iBAAEqB,UAAF,CAAa8B,iBAAb,CAAJ,EAAqC;AACnC,iBAAOA,mBAAP;AACD;AACF;;AAED,aACE;AAAA;AAAA;AACE,iBAAO5B,MAAM6B,SADf;AAEE,oBAAU,KAAKhD,iBAFjB;AAGE;AAHF;AAKE;AAAA;AAAA;AACE,iBAAK,KAAKC,eADZ;AAEE,mBAAO,CAACkB,MAAM8B,UAAP,EAAmB,EAAE3D,OAAO,KAAKkC,uBAAL,EAAT,EAAnB,CAFT;AAGE,4BAHF;AAIE,+BAJF;AAKE,qBAASsB,OALX;AAME,0BAAc,KANhB;AAOE,sBAAU,KAAKhD,kBAPjB;AAQE,iCAAqB,GARvB;AASE,mCAAuB,KATzB;AAUE,8CAAkC,KAVpC;AAWE,2BAAeQ,aAXjB;AAYE,4CAAgC,KAZlC;AAaE,0CAA8B;AAbhC;AAeG,eAAK4C,WAAL;AAfH,SALF;AAsBE;AAAA;AAAA,YAAM,WAAU,aAAhB,EAA8B,eAAc,UAA5C;AACG,eAAKL,aAAL;AADH;AAtBF,OADF;AA4BD;;;4BAxRMM,S,GAAY;AAGjBL,WAAS,iBAAUM,IAHF;;AAKjB1B,QAAM,iBAAU2B,OAAV,CACJ,iBAAUC,MADN,EAEJC,UAPe;;AAUjB1C,mBAAiB,iBAAU2C,IAVV;;AAYjB9D,cAAY,iBAAU+D,MAZL;;AAejBvB,cAAY,iBAAUsB,IAfL;;AAmBjBX,iBAAe,iBAAUW,IAnBR;;AAsBjBT,qBAAmB,iBAAUS,IAtBZ;;AAwBjBhE,iBAAe,iBAAUiE,MAxBR;;AA0BjBnD,iBAAe,iBAAU8C,IA1BR;;AA4BjBjC,SAAO,iBAAUmC,MA5BA;;AA8BjB3D,gBAAc,iBAAUyD,IA9BP;;AAmCjBrB,0BAAwB,iBAAU0B;AAnCjB,C,SAsCZC,Y,GAAe;AACpBhE,cAAY,CADQ;AAEpBF,iBAAe,CAFK;AAGpBG,gBAAc,KAHM;AAIpBoC,0BAAwB;AAJJ,C;;;AAqPxB,IAAM4B,wBAAwB,yBAAa,4BAAb,EAA2CxE,eAA3C,CAA9B;;QAG2BA,e,GAAzBwE,qB","sourcesContent":["import React, {\n  Component,\n  PropTypes,\n} from 'react';\n\nimport {\n  ScrollView,\n  InteractionManager,\n  LayoutAnimation,\n} from 'react-native';\n\nimport _ from 'lodash';\n\nimport { connectStyle } from '@shoutem/theme';\n\nimport {\n  View,\n} from '../../index';\n\nimport { Page } from './Page';\n\n/**\n * Renders a horizontal pager which renders pages by using\n * the renderPage function with provided data.\n *\n * It can be used as a general wrapper component for any group\n * of uniform components which require horizontal paging.\n * It abstracts away React Native API inconsistencies between\n * iOS and Android platforms and should be used instead of\n * ScrollView and ViewPagerAndroid for this matter.\n *\n */\nclass HorizontalPager extends Component {\n  static propTypes = {\n    // Prop defining whether the Pager will bounce back\n    // when user tries to swipe beyond end of content (iOS only)\n    bounces: PropTypes.bool,\n    // Array containing objects (pages)\n    data: PropTypes.arrayOf(\n      PropTypes.object,\n    ).isRequired,\n    // Callback function called when user swipes between pages (images)\n    // Index of new (selected) page is passed to this callback\n    onIndexSelected: PropTypes.func,\n    // Page margin, margin visible between pages, during swipe gesture.\n    pageMargin: PropTypes.number,\n    // A function which renders a single page\n    // renderPage(pageData, pageIndex)\n    renderPage: PropTypes.func,\n    // Callback function that can be used to render overlay over pages\n    // For example page indicators using `PageIndicators` component\n    // renderOverlay(pageData, pageIndex, layout)\n    renderOverlay: PropTypes.func,\n    // Callback function that can be used to define placeholder\n    // that appears when content is loading\n    renderPlaceholder: PropTypes.func,\n    // Initially selected page in gallery\n    selectedIndex: PropTypes.number,\n    // Prop that forces enables or disables swiping\n    scrollEnabled: PropTypes.bool,\n    // Style prop used to override default (theme) styling\n    style: PropTypes.object,\n    // Prop that reduces page size by pageMargin, allowing 'sneak peak' of next page\n    showNextPage: PropTypes.bool,\n    // Always render only central (currently loaded) page plus `surroundingPagesToLoad`\n    // to the left and to the right. If currently rendered page is out of bounds,\n    // empty `View` (with set dimensions for proper scrolling) will be rendered\n    // Defaults to 2.\n    surroundingPagesToLoad: PropTypes.number,\n  };\n\n  static defaultProps = {\n    pageMargin: 0,\n    selectedIndex: 0,\n    showNextPage: false,\n    surroundingPagesToLoad: 2,\n  };\n\n  constructor(props) {\n    super(props);\n    this.state = {\n      width: 0,\n      height: 0,\n      selectedIndex: this.props.selectedIndex,\n      initialSelectedIndex: this.props.selectedIndex,\n      pageMargin: this.props.pageMargin,\n      showNextPage: this.props.showNextPage,\n      shouldRenderContent: false,\n      scrolledToInitialIndex: false,\n    };\n    this.onHorizontalScroll = this.onHorizontalScroll.bind(this);\n    this.onLayoutContainer = this.onLayoutContainer.bind(this);\n    this.onScrollViewRef = this.onScrollViewRef.bind(this);\n  }\n\n  componentDidMount() {\n    InteractionManager.runAfterInteractions(() => {\n      LayoutAnimation.easeInEaseOut();\n      this.setState({ shouldRenderContent: true });\n    });\n  }\n\n  componentWillReceiveProps(nextProps) {\n    const { selectedIndex } = this.state;\n\n    if (this.props.scrollEnabled && !nextProps.scrollEnabled) {\n      this.scrollToPage(selectedIndex);\n    }\n  }\n\n  onLayoutContainer(event) {\n    const { width, height } = event.nativeEvent.layout;\n    const { scrolledToInitialIndex } = this.state;\n\n    if ((this.state.width === width) && (this.state.height === height)) {\n      return;\n    }\n\n    this.setState({ width, height }, () => {\n      // By checking has the pager scrolled to initial index, we're avoiding weird issue\n      // where pager would scroll back to initial index after swiping to other index\n      if (!scrolledToInitialIndex) {\n        requestAnimationFrame(() => this.scrollToInitialPage());\n      }\n    });\n  }\n\n  onHorizontalScroll(event) {\n    const { selectedIndex } = this.state;\n    const { onIndexSelected } = this.props;\n    const contentOffset = event.nativeEvent.contentOffset;\n\n    const newSelectedIndex = this.calculateIndex(contentOffset);\n    if (selectedIndex === newSelectedIndex) {\n      // Nothing to do, we are already at the new index\n      return;\n    }\n\n    // Handle the swipes between pages performed by the user\n    if (selectedIndex !== newSelectedIndex) {\n      this.setState({\n        selectedIndex: newSelectedIndex,\n      }, () => {\n        if (_.isFunction(onIndexSelected)) {\n          onIndexSelected(newSelectedIndex);\n        }\n      });\n    }\n  }\n\n  onScrollViewRef(scroller) {\n    this.scroller = scroller;\n  }\n\n  calculateContainerWidth() {\n    const { style } = this.props;\n    const { width, pageMargin, showNextPage } = this.state;\n    // If `showNextPage` is `true` then container must have width narrower\n    // By `nextPageInsetSize`, to allow rendering of small portion of next page\n    // While keeping `pageMargin` intact between pages\n    // If `showNextPage` is `false`, then `nextPageInsetSize` doesn't matter,\n    // And we only use `pageMargin` for spacing between pages.\n    return showNextPage ? (width - style.nextPageInsetSize) : (width + pageMargin);\n  }\n\n  scrollToPage(page) {\n    const { width } = this.state;\n\n    if (this.scroller && width && page) {\n      this.scroller.scrollTo({\n        x: page * this.calculateContainerWidth(),\n        animated: false,\n      });\n    }\n  }\n\n  scrollToInitialPage() {\n    const { onIndexSelected } = this.props;\n    const { initialSelectedIndex } = this.state;\n\n    this.scrollToPage(initialSelectedIndex);\n    this.setState({\n      selectedIndex: initialSelectedIndex,\n      scrolledToInitialIndex: true,\n    }, () => {\n      if (_.isFunction(onIndexSelected)) {\n        onIndexSelected(initialSelectedIndex);\n      }\n    });\n  }\n\n  calculateIndex(contentOffset) {\n    const { width, selectedIndex, pageMargin } = this.state;\n    const { data } = this.props;\n\n    let newSelectedIndex = selectedIndex;\n\n    if (contentOffset.x <= 0) {\n      newSelectedIndex = 0;\n    }\n\n    if (selectedIndex >= data.length - 1) {\n      newSelectedIndex = data.length - 1;\n    }\n\n    if (width && contentOffset.x > 0) {\n      newSelectedIndex = Math.round(contentOffset.x / (width + pageMargin));\n    }\n    return newSelectedIndex;\n  }\n\n  shouldRenderPage(index) {\n    const { data, surroundingPagesToLoad } = this.props;\n    const { selectedIndex } = this.state;\n\n    // We are rendering max surroundingPagesToLoad around the current index\n    const minPageIndex = (selectedIndex <= surroundingPagesToLoad) ?\n      0 : selectedIndex - surroundingPagesToLoad;\n\n    const maxPageIndex = (selectedIndex >= (data.length - surroundingPagesToLoad - 1)) ?\n      data.length - 1 : selectedIndex + surroundingPagesToLoad;\n\n    return (index >= minPageIndex) && (index <= maxPageIndex);\n  }\n\n  renderPages() {\n    const { width, height, pageMargin, showNextPage, selectedIndex } = this.state;\n    const { data, renderPage, style } = this.props;\n\n    const pages = data.map((pageData, pageIndex) => {\n      const lastPage = pageIndex === data.length - 1;\n      const containerWidth = this.calculateContainerWidth();\n      let pageWidth = width;\n\n      if (showNextPage && !lastPage) {\n        // If `showNextPage` is `true` then one page must have width narrower\n        // By pageMargin - nextPageInsetSize, to allow rendering of small portion of next page\n        // While keeping pageMargin intact between pages\n        pageWidth = width - pageMargin - style.nextPageInsetSize;\n      }\n\n      // Fixes where multiple pages appear at once on initial load (if surroundingPagesToLoad > 0)\n      if (!containerWidth) return null;\n\n      const isPageActive = (selectedIndex === pageIndex);\n      const pageContent = this.shouldRenderPage(pageIndex) && (\n        <Page\n          isActive={isPageActive}\n          width={pageWidth}\n          style={style.page}\n        >\n          {renderPage(pageData, pageIndex, { width, height })}\n        </Page>\n      );\n\n      return (\n        <View key={pageIndex} style={{ width: containerWidth }}>\n          {pageContent}\n        </View>\n      );\n    });\n    return pages;\n  }\n\n  renderOverlay() {\n    const { renderOverlay, data } = this.props;\n    const { selectedIndex } = this.state;\n\n    if (_.isFunction(renderOverlay)) {\n      return renderOverlay(data, selectedIndex);\n    }\n\n    return null;\n  }\n\n  render() {\n    const { bounces, scrollEnabled, style, renderPlaceholder } = this.props;\n    const { shouldRenderContent } = this.state;\n\n    if (!shouldRenderContent) {\n      if (_.isFunction(renderPlaceholder)) {\n        return renderPlaceholder();\n      }\n    }\n\n    return (\n      <View\n        style={style.container}\n        onLayout={this.onLayoutContainer}\n        virtual\n      >\n        <ScrollView\n          ref={this.onScrollViewRef}\n          style={[style.scrollView, { width: this.calculateContainerWidth() }]}\n          horizontal\n          pagingEnabled\n          bounces={bounces}\n          scrollsToTop={false}\n          onScroll={this.onHorizontalScroll}\n          scrollEventThrottle={200}\n          removeClippedSubviews={false}\n          automaticallyAdjustContentInsets={false}\n          scrollEnabled={scrollEnabled}\n          showsHorizontalScrollIndicator={false}\n          showsVerticalScrollIndicator={false}\n        >\n          {this.renderPages()}\n        </ScrollView>\n        <View styleName=\"fill-parent\" pointerEvents=\"box-none\">\n          {this.renderOverlay()}\n        </View>\n      </View>\n    );\n  }\n}\n\nconst StyledHorizontalPager = connectStyle('shoutem.ui.HorizontalPager')(HorizontalPager);\n\nexport {\n  StyledHorizontalPager as HorizontalPager,\n};\n"]}]