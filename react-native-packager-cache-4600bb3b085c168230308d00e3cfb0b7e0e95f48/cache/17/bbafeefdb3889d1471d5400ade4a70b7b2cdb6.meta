["f20853178efb55abb8aa1fa5228983fb14666f95","cda3888c411ec79846e13c9f2e79373b55439bfd",["react","lodash","../../components/View","../../components/Text","./Text","./Img","../../components/TouchableOpacity","../services/ElementRegistry","../Html"],[200,292,385,432,480,511,554,624,677],{"version":3,"sources":["/home/ziddi/Desktop/Bhupesh/venders/node_modules/@shoutem/ui/html/elements/Inline.js"],"names":["blockDisplayIfAnyChildIsBlock","element","childElements","BLOCK","INLINE","onlyInlineChildren","groupedChildren","last","length","isArray","getRightmostLeafChild","isString","size","handleLineBreak","elements","inlineElements","nextBlockElement","lastElement","push","tag","groupInlineNodes","onLineBreak","reduce","result","elem","renderGroupedChildren","renderElement","style","renderedChildren","map","child","renderedChild","isEmpty","text","Children","toArray","Inline","props","onPress","styleName","block","trimmedChildren","children","content","Container","container","Component","defaultProps","propTypes","PropTypes","func","InlineSettings","display"],"mappings":"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","sourcesContent":["import React from 'react';\nimport _ from 'lodash';\n\nimport { View } from '../../components/View';\nimport { Text } from '../../components/Text';\nimport { removeWhiteSpace, isText } from './Text';\nimport { isImg } from './Img';\nimport { TouchableOpacity } from '../../components/TouchableOpacity';\nimport { Display } from '../services/ElementRegistry';\nimport {\n  isBlockElement,\n  hasBlockElement,\n  ElementPropTypes,\n  combineMappers,\n  mapElementProps,\n  renderChildElements,\n} from '../Html';\n\nexport const blockDisplayIfAnyChildIsBlock = function (element) {\n  return hasBlockElement(element.childElements) ? Display.BLOCK : Display.INLINE;\n};\n\n/**\n * Based on {@link groupInlineNodes},\n * if all elements are inline there will only be one array.\n * @param groupedChildren {Array}\n * @returns {boolean}\n */\nfunction onlyInlineChildren(groupedChildren) {\n  const last = _.last(groupedChildren);\n  return groupedChildren.length === 1 && _.isArray(last);\n}\n\n/**\n * Get the leaf child of the element\n * @param element\n * @returns {*}\n */\nfunction getRightmostLeafChild(element) {\n  if (!element) {\n    return;\n  }\n  if (_.isString(element) || _.size(element.childElements) === 0) {\n    return element;\n  }\n  return getRightmostLeafChild(_.last(element.childElements));\n}\n\n/**\n * Handle element that breaks the line.\n * It will add br before the image element.\n * @param elements Elements to render in the Inline component\n * @param inlineElements Grouped inline elements\n * @param nextBlockElement The element which caused the line break\n */\nfunction handleLineBreak(elements, inlineElements = [], nextBlockElement) {\n  const lastElement = getRightmostLeafChild(_.last(inlineElements));\n\n  if (isImg(nextBlockElement) && isText(lastElement)) {\n    inlineElements.push({ tag: 'br' });\n  }\n\n  elements.push(nextBlockElement);\n}\n\n/**\n * Group connected (in a sequence) inline elements into array,\n * handle block elements with onLineBreak.\n *\n * For example:\n *  [i,i,i,b,i] => [[i,i,i], b, [i]]\n *\n * @param childElements {Array}\n * @returns {Array}\n */\nfunction groupInlineNodes(childElements, onLineBreak) {\n  // eslint-disable-next-line prefer-arrow-callback\n  return childElements.reduce(function (result, elem) {\n    let last = _.last(result);\n\n    if (!isBlockElement(elem)) {\n      if (!_.isArray(last)) {\n        last = [];\n        result.push(last);\n      }\n      last.push(elem);\n    } else {\n      onLineBreak(result, last, elem);\n    }\n\n    return result;\n  }, []);\n}\n\n/**\n * @param groupedChildren {Array}\n *  List of elements and arrays of grouped inline elements.\n *  Check {@link groupInlineNodes}\n * @param renderElement {Function}\n * @returns {Children} React Children\n */\nfunction renderGroupedChildren(groupedChildren, renderElement, style) {\n  // eslint-disable-next-line prefer-arrow-callback\n  const renderedChildren = groupedChildren.map(function (child) {\n    if (_.isArray(child)) {\n      // Inline elements must be wrapped with text to stay in the same line.\n      // Inline elements are grouped in the array, see {@link groupInlineNodes}\n      const renderedChild = renderChildElements(child, renderElement);\n      return _.isEmpty(renderedChild) ? null : <Text style={style.text}>{renderedChild}</Text>;\n    }\n    return renderElement(child);\n  });\n\n  return React.Children.toArray(renderedChildren);\n}\n\n// TODO\n// Implement groupInlineNodes as a method.\n// Add shouldBreakLine prop to get even more flexibility.\n/**\n * Should be used for inline HTML elements.\n * Because of specific RN behavior, the inline component will remain inline\n * only if every child (recursively) is inline as well.\n * If any child is not inline, the display will be block.\n * A container element is added around the children only when\n * inline element is used as a block element.\n * @param props {Object} Element attributes\n * @returns {component}\n * @constructor\n */\nexport class Inline extends React.Component {\n  static defaultProps = {\n    style: {},\n  };\n\n  static propTypes = {\n    ...ElementPropTypes,\n    onPress: React.PropTypes.func,\n    onLineBreak: React.PropTypes.func,\n  };\n\n  static defaultProps = {\n    onLineBreak: handleLineBreak,\n  };\n\n  renderGroupedChildren(groupedChildren) {\n    const { style, renderElement } = this.props;\n    // eslint-disable-next-line prefer-arrow-callback\n    const renderedChildren = groupedChildren.map(function (child) {\n      if (_.isArray(child)) {\n        // Inline elements must be wrapped with text to stay in the same line.\n        // Inline elements are grouped in the array, see {@link groupInlineNodes}\n        const renderedChild = renderChildElements(child, renderElement);\n        // It is important to style a text here so that it has the right style.\n        return _.isEmpty(renderedChild) ? null : <Text style={style.text}>{renderedChild}</Text>;\n      }\n      return renderElement(child);\n    });\n\n    return React.Children.toArray(renderedChildren);\n  }\n\n  render() {\n    const { childElements, style, onPress, onLineBreak, styleName, block } = this.props;\n\n    if (_.isEmpty(childElements)) {\n      return null;\n    }\n\n    // Browsers ignore white space (new lines) around element tags,\n    // we need to remove it here manually so it doesn't get rendered by RN.\n    const trimmedChildren = removeWhiteSpace(childElements);\n\n    // TODO - save prepared children (trimmed and grouped) in the state\n    // Group inline elements, such as text, so that\n    // it gets shown in the same line. Like concatenation.\n    // Block elements are standalone because they break the line.\n    const children = groupInlineNodes(trimmedChildren, onLineBreak);\n\n    let content = this.renderGroupedChildren(children);\n\n    if (onlyInlineChildren(children)) {\n      // Group textual nodes together.\n      // Used for right text wrapping.\n      content = (\n        <Text onPress={onPress} styleName={styleName}>\n          {content}\n        </Text>\n      );\n\n      // TODO - standardize block behavior\n      if (!block) {\n        return content;\n      }\n    }\n\n    const Container = onPress ? TouchableOpacity : View;\n    return (\n      <Container style={style.container} onPress={onPress} styleName={`block ${styleName}`}>\n        {content}\n      </Container>\n    );\n  }\n}\n\nexport const InlineSettings = { display: blockDisplayIfAnyChildIsBlock };\n\nexport default combineMappers(mapElementProps)(Inline);\n"]}]