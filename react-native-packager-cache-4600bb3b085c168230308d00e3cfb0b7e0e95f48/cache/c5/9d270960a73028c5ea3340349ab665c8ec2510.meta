["007861453f6a433175d9c2299df49ec6a7e3574a","04512252854920ae3be0e7b502d19d86c13d5f62",["react","react-native","hoist-non-react-statics","lodash","../drivers/DriverShape"],[132,229,283,423,517],{"version":3,"sources":["/home/ziddi/Desktop/Bhupesh/venders/node_modules/@shoutem/animation/src/components/connectAnimation.js"],"names":["connectAnimation","_","ANIMATION_SUFFIX","isComponentAnimated","props","animation","animationName","removeAnimationsFromStyle","style","omitBy","value","key","isFunction","endsWith","transferAnimatedValues","styleValue","animatedStyleValue","interpolate","isUndefined","resolveAnimatedStyle","driver","animations","layout","componentName","animationOptions","createAnimatedStyle","Error","animatedStyle","mergeWith","defaultOptions","createAnimatedComponent","WrappedComponent","options","AnimatedWrappedComponent","AnimatedComponent","context","onLayout","bind","resolveStyle","setWrappedInstance","transformProps","state","height","width","x","y","resolvedStyle","nextProps","nextContext","getDriver","event","nativeEvent","isEqual","setState","animationDriver","displayName","name","nativeProps","wrappedInstance","setNativeProps","component","sourceProps","ConnectedComponent","propTypes","PropTypes","object","string","func","defaultProps","contextTypes","childContextTypes"],"mappings":"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","sourcesContent":["import React, { Component } from 'react';\nimport { Animated } from 'react-native';\nimport hoistStatics from 'hoist-non-react-statics';\nimport * as _ from 'lodash';\n\nimport { DriverShape } from '../drivers/DriverShape';\n\nconst ANIMATION_SUFFIX = 'Animation';\n\nfunction isComponentAnimated(props) {\n  return props.animation || props.animationName;\n}\n\nfunction removeAnimationsFromStyle(style) {\n  return _.omitBy(style, (value, key) => _.isFunction(value) && _.endsWith(key, ANIMATION_SUFFIX));\n}\n\n/**\n * This function transfers styles that are created by animated interpolations\n * and it does that recursively because sometimes style is an object/array\n * which contains styles created by animated interpolations\n */\nfunction transferAnimatedValues(styleValue, animatedStyleValue, key) {\n  if(_.isFunction(animatedStyleValue.interpolate) || _.isUndefined(styleValue)) {\n    return animatedStyleValue;\n  }\n}\n\nfunction resolveAnimatedStyle({\n  props,\n  driver,\n  animations,\n  layout = {},\n  componentName = 'component',\n}) {\n  const {\n    style,\n    animation,\n    animationName,\n    animationOptions,\n  } = props;\n\n  if (!isComponentAnimated(props)) {\n    return removeAnimationsFromStyle(style);\n  }\n\n  const createAnimatedStyle =\n    animation ||\n    animations[`${animationName}${ANIMATION_SUFFIX}`] ||\n    style[`${animationName}${ANIMATION_SUFFIX}`];\n\n  if (!_.isFunction(createAnimatedStyle)) {\n    throw new Error(`Animation with name: ${animationName}, you tried to assign to ` +\n      `to the ${componentName} doesn't exist. Check ${componentName}'s style or its declaration, ` +\n      'to find an exact error');\n  }\n\n  if (!driver) {\n    throw new Error(`You tried to animate ${componentName} with animation named ${animationName} ` +\n      `but you didn't pass driver to ${componentName}.`);\n  }\n\n  const animatedStyle = createAnimatedStyle(driver, { layout, animationOptions });\n\n  return _.mergeWith(removeAnimationsFromStyle(style), animatedStyle, transferAnimatedValues);\n}\n\nconst defaultOptions = {\n  createAnimatedComponent: true,\n};\n\n/**\n * Higher order component that creates animated component which could be animated by\n * list of passed animations. Animations are ran by driver, that could be send through\n * context as animationDriver, or passed as prop named driver. Driver provides animated value.\n * Each animation is a function which takes driver and context as parameters,\n * animation name should have \"Animation\" suffix. Context contains animation options,\n * and component's layout.\n * Example animation:\n *\n * fadeOutAnimation(driver, context) {\n *  return {\n *    opacity: driver.value.interpolate({\n *      inputRange: [0, context.layout.height],\n *      outputRange: [1, 0]\n *    })\n *  }\n * }\n *\n * in described animation component would fadeOut when scroll is equal its height\n * @param WrappedComponent component you want to be Animated\n * @param animations collection of available animations\n * @param options additional connect options\n * @param options.createAnimatedComponent determines if the connected component\n *   will be wrapped in an animated component, true by default. You may set this\n *   to false if your component already knows how to work with animated style values.\n */\nexport function connectAnimation(WrappedComponent, animations = {}, options = defaultOptions) {\n  const AnimatedWrappedComponent = options.createAnimatedComponent ?\n    Animated.createAnimatedComponent(WrappedComponent) :\n    WrappedComponent;\n\n  class AnimatedComponent extends Component {\n    static propTypes = {\n      /**\n       * Animation Driver an instance of driver that will be used to create animated style\n       */\n      driver: DriverShape,\n      /**\n       * Component style (could contain animation functions)\n       */\n      style: React.PropTypes.object,\n      /**\n       * Animation name it should match `${animationName}Animation` function passed in\n       * animations collection or component's style.\n       * e.g. if animationName is fadeOut there should exist function fadeOutAnimation\n       * in animations or style\n       */\n      animationName: React.PropTypes.string,\n      /**\n       * Options that would be passed to animation through context\n       */\n      animationOptions: React.PropTypes.object,\n      /**\n       * Explicit animation function declaration with signature:\n       * function (driver, context) {\n       *  return {\n       *    ...animated style\n       *  };\n       * }\n       * and it should return style object\n       */\n      animation: React.PropTypes.func,\n    };\n\n    static defaultProps = {\n      animationOptions: {},\n    };\n\n    static contextTypes = {\n      animationDriver: DriverShape,\n      transformProps: React.PropTypes.func,\n    };\n\n    static childContextTypes = {\n      transformProps: React.PropTypes.func,\n    };\n\n    constructor(props, context) {\n      super(props, context);\n      this.onLayout = this.onLayout.bind(this);\n      this.resolveStyle = this.resolveStyle.bind(this);\n      this.setWrappedInstance = this.setWrappedInstance.bind(this);\n      this.transformProps = this.transformProps.bind(this);\n      this.state = {\n        layout: {\n          height: 0,\n          width: 0,\n          x: 0,\n          y: 0,\n        },\n        resolvedStyle: removeAnimationsFromStyle(props.style),\n      };\n    }\n\n    getChildContext() {\n      return {\n        transformProps: this.transformProps,\n      };\n    }\n\n    componentWillReceiveProps(nextProps, nextContext) {\n      this.resolveStyle(nextProps, this.getDriver(nextProps, nextContext));\n    }\n\n    onLayout(event) {\n      const { layout } = event.nativeEvent;\n      const driver = this.getDriver();\n      if (!_.isEqual(layout, this.state.layout)) {\n        this.setState({ layout }, () => this.resolveStyle(this.props, driver));\n      }\n    }\n\n    getDriver(props = this.props, context = this.context) {\n      return props.driver || context.animationDriver;\n    }\n\n    resolveStyle(props, driver) {\n      this.setState({\n        resolvedStyle: resolveAnimatedStyle({\n          props,\n          driver,\n          animations,\n          layout: this.state.layout,\n          componentName: WrappedComponent.displayName || WrappedComponent.name,\n        }),\n      });\n    }\n\n    setNativeProps(nativeProps) {\n      if (this.wrappedInstance.setNativeProps) {\n        this.wrappedInstance.setNativeProps(nativeProps);\n      }\n    }\n\n    setWrappedInstance(component) {\n      this.wrappedInstance = component;\n    }\n\n    /**\n     * A helper function provided to child components that enables\n     * them to get the prop transformations that this component performs.\n     *\n     * @param props The component props to transform.\n     * @returns {*} The transformed props.\n     */\n    transformProps(props) {\n      const sourceProps = this.context.transformProps ?\n        this.context.transformProps(props) : props;\n\n      return {\n        ...sourceProps,\n        style: resolveAnimatedStyle({\n          props: sourceProps,\n          driver: this.getDriver(sourceProps, this.context),\n          animations,\n          layout: this.state.layout,\n          componentName: WrappedComponent.displayName || WrappedComponent.name,\n        }),\n      };\n    }\n\n    render() {\n      const { resolvedStyle } = this.state;\n      const ConnectedComponent = isComponentAnimated(this.props) ?\n        AnimatedWrappedComponent :\n        WrappedComponent;\n\n      return (\n        <ConnectedComponent\n          onLayout={this.onLayout}\n          {...this.props}\n          style={resolvedStyle}\n          ref={this.setWrappedInstance}\n        />\n      );\n    }\n  }\n\n  return hoistStatics(AnimatedComponent, WrappedComponent);\n}\n"]}]