["1cedde6ceed8393a8143285482542b825d17e2db","17829641179d4e0a3447136448048e6fe187991d",[],[],{"version":3,"sources":["/home/ziddi/Desktop/Bhupesh/venders/node_modules/sc-formatter/index.js"],"names":["base64Chars","arrayBufferToBase64","arraybuffer","bytes","Uint8Array","len","length","base64","i","substring","binaryToBase64Replacer","key","value","global","ArrayBuffer","data","Buffer","toString","type","Array","rehydratedBuffer","from","module","exports","decode","input","message","JSON","parse","err","encode","object","stringify"],"mappings":"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","sourcesContent":["var base64Chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\nvar arrayBufferToBase64 = function (arraybuffer) {\n  var bytes = new Uint8Array(arraybuffer);\n  var len = bytes.length;\n  var base64 = '';\n\n  for (var i = 0; i < len; i += 3) {\n    base64 += base64Chars[bytes[i] >> 2];\n    base64 += base64Chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n    base64 += base64Chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n    base64 += base64Chars[bytes[i + 2] & 63];\n  }\n\n  if ((len % 3) === 2) {\n    base64 = base64.substring(0, base64.length - 1) + '=';\n  } else if (len % 3 === 1) {\n    base64 = base64.substring(0, base64.length - 2) + '==';\n  }\n\n  return base64;\n};\n\nvar binaryToBase64Replacer = function (key, value) {\n  if (global.ArrayBuffer && value instanceof global.ArrayBuffer) {\n    return {\n      base64: true,\n      data: arrayBufferToBase64(value)\n    };\n  } else if (global.Buffer) {\n    if (value instanceof global.Buffer){\n      return {\n        base64: true,\n        data: value.toString('base64')\n      };\n    }\n    // Some versions of Node.js convert Buffers to Objects before they are passed to\n    // the replacer function - Because of this, we need to rehydrate Buffers\n    // before we can convert them to base64 strings.\n    if (value && value.type == 'Buffer' && value.data instanceof Array) {\n      var rehydratedBuffer;\n      if (global.Buffer.from) {\n        rehydratedBuffer = global.Buffer.from(value.data);\n      } else {\n        rehydratedBuffer = new global.Buffer(value.data);\n      }\n      return {\n        base64: true,\n        data: rehydratedBuffer.toString('base64')\n      };\n    }\n  }\n  return value;\n};\n\n// Decode the data which was transmitted over the wire to a JavaScript Object in a format which SC understands.\n// See encode function below for more details.\nmodule.exports.decode = function (input) {\n  if (input == null) {\n   return null;\n  }\n  // Leave ping or pong message as is\n  if (input == '#1' || input == '#2') {\n    return input;\n  }\n  var message = input.toString();\n\n  try {\n    return JSON.parse(message);\n  } catch (err) {}\n  return message;\n};\n\n\n// Encode a raw JavaScript object (which is in the SC protocol format) into a format for\n// transfering it over the wire. In this case, we just convert it into a simple JSON string.\n// If you want to create your own custom codec, you can encode the object into any format\n// (e.g. binary ArrayBuffer or string with any kind of compression) so long as your decode\n// function is able to rehydrate that object back into its original JavaScript Object format\n// (which adheres to the SC protocol).\n// See https://github.com/SocketCluster/socketcluster/blob/master/socketcluster-protocol.md\n// for details about the SC protocol.\nmodule.exports.encode = function (object) {\n  // Leave ping or pong message as is\n  if (object == '#1' || object == '#2') {\n    return object;\n  }\n  return JSON.stringify(object, binaryToBase64Replacer);\n};\n"]}]