["6a78477014e941c0cef8aa9b88f1b5c58dc3d3cc","968bbc68c6aabe87fe4d0d340ab76c34169dc1b8",["./scsocket","sc-errors"],[23,61],{"version":3,"sources":["/home/ziddi/Desktop/venders/node_modules/socketcluster-client/lib/scsocketcreator.js"],"names":["SCSocket","require","scErrors","InvalidArgumentsError","_connections","getMultiplexId","options","protocolPrefix","secure","queryString","query","queryArray","queryMap","key","hasOwnProperty","push","length","join","host","hostname","port","path","isUrlSecure","global","location","protocol","getPort","isSecureDefault","isSecure","connect","self","opts","autoConnect","autoReconnect","autoProcessSubscriptions","connectTimeout","ackTimeout","timestampRequests","timestampParam","authEngine","authTokenName","binaryType","multiplex","cloneData","i","multiplexId","destroy","socket","disconnect","module","exports","connections"],"mappings":"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","sourcesContent":["var SCSocket = require('./scsocket');\nvar scErrors = require('sc-errors');\nvar InvalidArgumentsError = scErrors.InvalidArgumentsError;\n\nvar _connections = {};\n\nfunction getMultiplexId(options) {\n  var protocolPrefix = options.secure ? 'https://' : 'http://';\n  var queryString = '';\n  if (options.query) {\n    if (typeof options.query == 'string') {\n      queryString = options.query;\n    } else {\n      var queryArray = [];\n      var queryMap = options.query;\n      for (var key in queryMap) {\n        if (queryMap.hasOwnProperty(key)) {\n          queryArray.push(key + '=' + queryMap[key]);\n        }\n      }\n      if (queryArray.length) {\n        queryString = '?' + queryArray.join('&');\n      }\n    }\n  }\n  var host;\n  if (options.host) {\n    host = options.host;\n  } else {\n    host = options.hostname + ':' + options.port;\n  }\n  return protocolPrefix + host + options.path + queryString;\n}\n\nfunction isUrlSecure() {\n  return global.location && location.protocol == 'https:';\n}\n\nfunction getPort(options, isSecureDefault) {\n  var isSecure = options.secure == null ? isSecureDefault : options.secure;\n  return options.port || (global.location && location.port ? location.port : isSecure ? 443 : 80);\n}\n\nfunction connect(options) {\n  var self = this;\n\n  options = options || {};\n\n  if (options.host && options.port) {\n    throw new InvalidArgumentsError('The host option should already include the' +\n      ' port number in the format hostname:port - Because of this, the host and port options' +\n      ' cannot be specified together; use the hostname option instead');\n  }\n\n  var isSecureDefault = isUrlSecure();\n\n  var opts = {\n    port: getPort(options, isSecureDefault),\n    hostname: global.location && location.hostname,\n    path: '/socketcluster/',\n    secure: isSecureDefault,\n    autoConnect: true,\n    autoReconnect: true,\n    autoProcessSubscriptions: true,\n    connectTimeout: 20000,\n    ackTimeout: 10000,\n    timestampRequests: false,\n    timestampParam: 't',\n    authEngine: null,\n    authTokenName: 'socketCluster.authToken',\n    binaryType: 'arraybuffer',\n    multiplex: true,\n    cloneData: false\n  };\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n  var multiplexId = getMultiplexId(opts);\n  if (opts.multiplex === false) {\n    return new SCSocket(opts);\n  }\n  if (_connections[multiplexId]) {\n    _connections[multiplexId].connect();\n  } else {\n    _connections[multiplexId] = new SCSocket(opts);\n  }\n  return _connections[multiplexId];\n}\n\nfunction destroy(options) {\n  var self = this;\n\n  options = options || {};\n  var isSecureDefault = isUrlSecure();\n\n  var opts = {\n    port: getPort(options, isSecureDefault),\n    hostname: global.location && location.hostname,\n    path: '/socketcluster/',\n    secure: isSecureDefault\n  };\n  for (var i in options) {\n    if (options.hasOwnProperty(i)) {\n      opts[i] = options[i];\n    }\n  }\n  var multiplexId = getMultiplexId(opts);\n  var socket = _connections[multiplexId];\n  if (socket) {\n    socket.disconnect();\n  }\n  delete _connections[multiplexId];\n}\n\nmodule.exports = {\n  connect: connect,\n  destroy: destroy,\n  connections: _connections\n};\n"]}]