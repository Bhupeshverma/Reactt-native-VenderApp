["43927b578c808ee5db6ce600262f05bc8bb8a0f1","01ee75e54df94f696c2dd2ba5bb7fd8c5248f20a",["htmlparser2"],[123],{"version":3,"sources":["/home/ziddi/Desktop/venders/node_modules/@shoutem/ui/html/services/HtmlParser.js"],"names":["parseHtml","decodeHtmlEntities","str","replace","match","numStr","num","parseInt","String","fromCharCode","createElementNode","tag","attributes","childElements","parent","htmlNewLineRegex","RegExp","newLineAfterClosingTagRegex","newLineBeforeOpeningTagRegex","stripNewLines","html","test","trim","HtmlTree","rootTag","rootNode","activeNode","openTag","bind","appendText","closeTag","element","addChild","push","text","trimmedText","length","undefined","getParent","htmlTree","parser","Parser","onopentag","ontext","onclosetag","strippedHtml","write","end"],"mappings":"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","sourcesContent":["import htmlparser2 from 'htmlparser2';\n\n/**\n * Decode HTML \"entities\" (special characters)\n * to the human readable format.\n * For example `&gt;` to `>`.\n * @param str {String} Raw HTML\n * @returns {string}\n */\nfunction decodeHtmlEntities(str) {\n  return str.replace(/&#([0-9]{1,3});/gi, (match, numStr) => {\n    const num = parseInt(numStr, 10); // read num as normal number\n    return String.fromCharCode(num);\n  });\n}\n\nfunction createElementNode(tag, attributes = {}, childElements = [], parent) {\n  return {\n    tag,\n    attributes,\n    childElements,\n    parent,\n  };\n}\n\n// Html new line regex\nconst htmlNewLineRegex = new RegExp('(>\\\\n)|(\\\\n<)|(\\\\n)', 'g');\nconst newLineAfterClosingTagRegex = new RegExp('>\\\\n');\nconst newLineBeforeOpeningTagRegex = new RegExp('\\\\n<');\n\n/**\n * Try to handle new lines as the browsers.\n * All new lines beside the ones next to the < or > will be replaced with the whitespace.\n * Those next to the < and > will be replaced with the empty string so that paragraph doesn't\n * start with the whitespace.\n * @param html\n */\nfunction stripNewLines(html) {\n  return html.replace(htmlNewLineRegex, (match) => {\n      if (newLineAfterClosingTagRegex.test(match)) {\n        return '>';\n      } else if (newLineBeforeOpeningTagRegex.test(match)) {\n        return '<';\n      }\n      return ' ';\n    }\n  ).trim();\n}\n\n/**\n * Use to create (save) a HTML tree copy out of element nodes\n * by recursively going through the HTML tree,\n * from a root node to the last child of the tree.\n */\nclass HtmlTree {\n  /**\n   * Set a tree basic nodes.\n   * @param rootElementTag {String} The root element tag is safety wrapper around a parsed HTML\n   *   because the HTML can have multiple root elements which is not supported by the RN.\n   */\n  constructor(rootTag = 'div') {\n    this.rootNode = createElementNode(rootTag);\n    this.activeNode = this.rootNode;\n    this.openTag = this.openTag.bind(this);\n    this.appendText = this.appendText.bind(this);\n    this.closeTag = this.closeTag.bind(this);\n  }\n\n  /**\n   * Create new element, add it to active node, and set it as active.\n   * @param tag {String} Element Tag name\n   * @param attributes {Object} Element attributes\n   * @param childElements {Array} Element children\n   */\n  openTag(tag, attributes, childElements) {\n    const element = this.addChild(tag, attributes, childElements);\n    this.activeNode = element;\n  }\n\n  /**\n   * Create new element and add to active node.\n   * @param tag {String} Element Tag name\n   * @param attributes {Object} Element attributes\n   * @param childElements {Array} Element children\n   * @returns {Element}\n   */\n  addChild(tag, attributes, childElements) {\n    const element = createElementNode(tag, attributes, childElements, this.activeNode);\n\n    this.activeNode.childElements.push(element);\n\n    return element;\n  }\n\n  /**\n   * Add text element to active node.\n   * @param text\n   */\n  appendText(text) {\n    const trimmedText = text.trim();\n    if (trimmedText.length === 0) {\n      // Whitespace around element tags is ignored\n      return;\n    }\n    this.addChild('text', undefined, [decodeHtmlEntities(text)]);\n  }\n\n  getParent() {\n    return this.activeNode.parent;\n  }\n\n  closeTag() {\n    this.activeNode = this.getParent();\n  }\n\n  getRootNode() {\n    return this.rootNode;\n  }\n}\n\n/**\n * Create a HtmlTree copy from a raw HTML wrapped with rootTag.\n * @param html {String} Raw HTML\n * @param rootTag {String} Root element tag\n * @returns {HtmlTree}\n */\nexport function parseHtml(html, rootTag = 'div') {\n  const htmlTree = new HtmlTree(rootTag);\n\n  const parser = new htmlparser2.Parser({\n    onopentag: htmlTree.openTag,\n    ontext: htmlTree.appendText,\n    onclosetag: htmlTree.closeTag,\n  });\n\n  // The browsers ignore new lines so we are skipping them as well.\n  const strippedHtml = stripNewLines(html);\n\n  parser.write(strippedHtml);\n  parser.end();\n\n  return htmlTree;\n}\n"]}]