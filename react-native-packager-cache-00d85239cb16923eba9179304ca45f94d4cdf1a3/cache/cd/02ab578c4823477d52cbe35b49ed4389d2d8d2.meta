["a39ac811a653dce474b5f3740e6f0fd8895da78e","4eafda141e9380f2ad439cec127815ed36a979a7",["react","clamp","react-native","./Card","./Header","../NavigationActions","../addNavigationHelpers","./SceneView","./TransitionConfigs"],[87,178,275,313,404,512,657,800,917],{"version":3,"sources":["/home/ziddi/Desktop/venders/node_modules/react-navigation/src/views/CardStack.js"],"names":["emptyFunction","ANIMATION_DURATION","POSITION_THRESHOLD","RESPOND_THRESHOLD","GESTURE_RESPONSE_DISTANCE_HORIZONTAL","GESTURE_RESPONSE_DISTANCE_VERTICAL","animatedSubscribeValue","animatedValue","__isNative","Object","keys","_listeners","length","addListener","CardStack","_gestureStartValue","_isResponding","_immediateIndex","_screenDetails","_getScreenDetails","scene","props","screenProps","navigation","router","screenDetails","key","state","route","screenNavigation","options","getScreenOptions","_renderCard","isModal","mode","getTransitionConfig","transitionConfig","screenInterpolator","style","SceneComponent","getComponentForRouteName","routeName","cardStyle","_renderInnerScene","scenes","forEach","newScene","headerMode","header","renderHeader","passProps","getScreenDetails","layout","width","height","position","resetToIndex","duration","timing","toValue","easing","linear","useNativeDriver","start","backFromIndex","Math","max","backFromScene","find","s","index","dispatch","back","floatingHeader","_getHeaderMode","_renderHeader","isVertical","responder","create","onPanResponderTerminate","_reset","onPanResponderGrant","stopAnimation","value","onMoveShouldSetPanResponder","event","gesture","immediateIndex","currentDragDistance","currentDragPosition","nativeEvent","axisLength","__getValue","axisHasBeenMeasured","screenEdgeDistance","gestureResponseDistance","hasDraggedEnough","abs","isOnFirstCard","shouldSetResponder","onPanResponderMove","startValue","axis","axisDistance","currentValue","isRTL","setValue","onPanResponderTerminationRequest","onPanResponderRelease","movedDistance","defaultVelocity","gestureVelocity","velocity","resetDuration","goBackDuration","_goBack","gesturesEnabled","OS","handlers","panHandlers","styles","container","map","flex","flexDirection"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport React, { Component } from 'react';\n\nimport clamp from 'clamp';\nimport {\n  Animated,\n  StyleSheet,\n  PanResponder,\n  Platform,\n  View,\n  I18nManager,\n  Easing,\n} from 'react-native';\n\nimport Card from './Card';\nimport Header from './Header';\nimport NavigationActions from '../NavigationActions';\nimport addNavigationHelpers from '../addNavigationHelpers';\nimport SceneView from './SceneView';\n\nimport type {\n  NavigationAction,\n  NavigationLayout,\n  NavigationScreenProp,\n  NavigationScene,\n  NavigationRouter,\n  NavigationState,\n  NavigationScreenDetails,\n  NavigationStackScreenOptions,\n  HeaderMode,\n  Style,\n  TransitionConfig,\n} from '../TypeDefinition';\n\nimport TransitionConfigs from './TransitionConfigs';\n\nconst emptyFunction = () => {};\n\ntype Props = {\n  screenProps?: {},\n  headerMode: HeaderMode,\n  headerComponent?: ReactClass<*>,\n  mode: 'card' | 'modal',\n  navigation: NavigationScreenProp<NavigationState, NavigationAction>,\n  router: NavigationRouter<\n    NavigationState,\n    NavigationAction,\n    NavigationStackScreenOptions\n  >,\n  cardStyle?: Style,\n  onTransitionStart?: () => void,\n  onTransitionEnd?: () => void,\n  style?: any,\n  /**\n   * Optional custom animation when transitioning between screens.\n   */\n  transitionConfig?: () => TransitionConfig,\n\n  // NavigationTransitionProps:\n  layout: NavigationLayout,\n  navigation: NavigationScreenProp<NavigationState, NavigationAction>,\n  position: Animated.Value,\n  progress: Animated.Value,\n  scenes: Array<NavigationScene>,\n  scene: NavigationScene,\n  index: number,\n};\n\n/**\n * The max duration of the card animation in milliseconds after released gesture.\n * The actual duration should be always less then that because the rest distance \n * is always less then the full distance of the layout.\n */\nconst ANIMATION_DURATION = 500;\n\n/**\n * The gesture distance threshold to trigger the back behavior. For instance,\n * `1/2` means that moving greater than 1/2 of the width of the screen will\n * trigger a back action\n */\nconst POSITION_THRESHOLD = 1 / 2;\n\n/**\n * The threshold (in pixels) to start the gesture action.\n */\nconst RESPOND_THRESHOLD = 20;\n\n/**\n * The distance of touch start from the edge of the screen where the gesture will be recognized\n */\nconst GESTURE_RESPONSE_DISTANCE_HORIZONTAL = 25;\nconst GESTURE_RESPONSE_DISTANCE_VERTICAL = 135;\n\nconst animatedSubscribeValue = (animatedValue: Animated.Value) => {\n  if (!animatedValue.__isNative) {\n    return;\n  }\n  if (Object.keys(animatedValue._listeners).length === 0) {\n    animatedValue.addListener(emptyFunction);\n  }\n};\n\nclass CardStack extends Component {\n  /**\n   * Used to identify the starting point of the position when the gesture starts, such that it can\n   * be updated according to its relative position. This means that a card can effectively be\n   * \"caught\"- If a gesture starts while a card is animating, the card does not jump into a\n   * corresponding location for the touch.\n   */\n  _gestureStartValue: number = 0;\n\n  // tracks if a touch is currently happening\n  _isResponding: boolean = false;\n\n  /**\n   * immediateIndex is used to represent the expected index that we will be on after a\n   * transition. To achieve a smooth animation when swiping back, the action to go back\n   * doesn't actually fire until the transition completes. The immediateIndex is used during\n   * the transition so that gestures can be handled correctly. This is a work-around for\n   * cases when the user quickly swipes back several times.\n   */\n  _immediateIndex: ?number = null;\n\n  _screenDetails: {\n    [key: string]: ?NavigationScreenDetails<NavigationStackScreenOptions>,\n  } = {};\n\n  props: Props;\n\n  componentWillReceiveProps(props: Props) {\n    if (props.screenProps !== this.props.screenProps) {\n      this._screenDetails = {};\n    }\n    props.scenes.forEach((newScene: *) => {\n      if (\n        this._screenDetails[newScene.key] &&\n        this._screenDetails[newScene.key].state !== newScene.route\n      ) {\n        this._screenDetails[newScene.key] = null;\n      }\n    });\n  }\n\n  _getScreenDetails = (scene: NavigationScene): NavigationScreenDetails<*> => {\n    const { screenProps, navigation, router } = this.props;\n    let screenDetails = this._screenDetails[scene.key];\n    if (!screenDetails || screenDetails.state !== scene.route) {\n      const screenNavigation = addNavigationHelpers({\n        ...navigation,\n        state: scene.route,\n      });\n      screenDetails = {\n        state: scene.route,\n        navigation: screenNavigation,\n        options: router.getScreenOptions(screenNavigation, screenProps),\n      };\n      this._screenDetails[scene.key] = screenDetails;\n    }\n    return screenDetails;\n  };\n\n  _renderHeader(\n    scene: NavigationScene,\n    headerMode: HeaderMode\n  ): ?React.Element<*> {\n    const { header } = this._getScreenDetails(scene).options;\n\n    if (typeof header !== 'undefined' && typeof header !== 'function') {\n      return header;\n    }\n\n    const renderHeader = header || ((props: *) => <Header {...props} />);\n\n    // We need to explicitly exclude `mode` since Flow doesn't see\n    // mode: headerMode override below and reports prop mismatch\n    const { mode, ...passProps } = this.props;\n\n    return renderHeader({\n      ...passProps,\n      scene,\n      mode: headerMode,\n      getScreenDetails: this._getScreenDetails,\n    });\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  _animatedSubscribe(props: Props) {\n    // Hack to make this work with native driven animations. We add a single listener\n    // so the JS value of the following animated values gets updated. We rely on\n    // some Animated private APIs and not doing so would require using a bunch of\n    // value listeners but we'd have to remove them to not leak and I'm not sure\n    // when we'd do that with the current structure we have. `stopAnimation` callback\n    // is also broken with native animated values that have no listeners so if we\n    // want to remove this we have to fix this too.\n    animatedSubscribeValue(props.layout.width);\n    animatedSubscribeValue(props.layout.height);\n    animatedSubscribeValue(props.position);\n  }\n\n  _reset(resetToIndex: number, duration: number): void {\n    Animated.timing(this.props.position, {\n      toValue: resetToIndex,\n      duration,\n      easing: Easing.linear(),\n      useNativeDriver: this.props.position.__isNative,\n    }).start();\n  }\n\n  _goBack(backFromIndex: number, duration: number) {\n    const { navigation, position, scenes } = this.props;\n    const toValue = Math.max(backFromIndex - 1, 0);\n\n    // set temporary index for gesture handler to respect until the action is\n    // dispatched at the end of the transition.\n    this._immediateIndex = toValue;\n\n    Animated.timing(position, {\n      toValue,\n      duration,\n      easing: Easing.linear(),\n      useNativeDriver: position.__isNative,\n    }).start(() => {\n      this._immediateIndex = null;\n      const backFromScene = scenes.find((s: *) => s.index === toValue + 1);\n      if (!this._isResponding && backFromScene) {\n        navigation.dispatch(\n          NavigationActions.back({ key: backFromScene.route.key })\n        );\n      }\n    });\n  }\n\n  render(): React.Element<*> {\n    let floatingHeader = null;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'float') {\n      floatingHeader = this._renderHeader(this.props.scene, headerMode);\n    }\n    const { navigation, position, layout, scene, scenes, mode } = this.props;\n    const { index } = navigation.state;\n    const isVertical = mode === 'modal';\n\n    const responder = PanResponder.create({\n      onPanResponderTerminate: () => {\n        this._isResponding = false;\n        this._reset(index, 0);\n      },\n      onPanResponderGrant: () => {\n        position.stopAnimation((value: number) => {\n          this._isResponding = true;\n          this._gestureStartValue = value;\n        });\n      },\n      onMoveShouldSetPanResponder: (\n        event: { nativeEvent: { pageY: number, pageX: number } },\n        gesture: any\n      ) => {\n        if (index !== scene.index) {\n          return false;\n        }\n        const immediateIndex = this._immediateIndex == null\n          ? index\n          : this._immediateIndex;\n        const currentDragDistance = gesture[isVertical ? 'dy' : 'dx'];\n        const currentDragPosition =\n          event.nativeEvent[isVertical ? 'pageY' : 'pageX'];\n        const axisLength = isVertical\n          ? layout.height.__getValue()\n          : layout.width.__getValue();\n        const axisHasBeenMeasured = !!axisLength;\n\n        // Measure the distance from the touch to the edge of the screen\n        const screenEdgeDistance = currentDragPosition - currentDragDistance;\n        // Compare to the gesture distance relavant to card or modal\n        const gestureResponseDistance = isVertical\n          ? GESTURE_RESPONSE_DISTANCE_VERTICAL\n          : GESTURE_RESPONSE_DISTANCE_HORIZONTAL;\n        // GESTURE_RESPONSE_DISTANCE is about 25 or 30. Or 135 for modals\n        if (screenEdgeDistance > gestureResponseDistance) {\n          // Reject touches that started in the middle of the screen\n          return false;\n        }\n\n        const hasDraggedEnough =\n          Math.abs(currentDragDistance) > RESPOND_THRESHOLD;\n\n        const isOnFirstCard = immediateIndex === 0;\n        const shouldSetResponder =\n          hasDraggedEnough && axisHasBeenMeasured && !isOnFirstCard;\n        return shouldSetResponder;\n      },\n      onPanResponderMove: (event: any, gesture: any) => {\n        // Handle the moving touches for our granted responder\n        const startValue = this._gestureStartValue;\n        const axis = isVertical ? 'dy' : 'dx';\n        const axisDistance = isVertical\n          ? layout.height.__getValue()\n          : layout.width.__getValue();\n        const currentValue = I18nManager.isRTL && axis === 'dx'\n          ? startValue + gesture[axis] / axisDistance\n          : startValue - gesture[axis] / axisDistance;\n        const value = clamp(index - 1, currentValue, index);\n        position.setValue(value);\n      },\n      onPanResponderTerminationRequest: () =>\n        // Returning false will prevent other views from becoming responder while\n        // the navigation view is the responder (mid-gesture)\n        false,\n      onPanResponderRelease: (event: any, gesture: any) => {\n        if (!this._isResponding) {\n          return;\n        }\n        this._isResponding = false;\n\n        const immediateIndex = this._immediateIndex == null\n          ? index\n          : this._immediateIndex;\n\n        // Calculate animate duration according to gesture speed and moved distance\n        const axisDistance = isVertical\n          ? layout.height.__getValue()\n          : layout.width.__getValue();\n        const movedDistance = gesture[isVertical ? 'moveY' : 'moveX'];\n        const defaultVelocity = axisDistance / ANIMATION_DURATION;\n        const gestureVelocity = gesture[isVertical ? 'vy' : 'vx'];\n        const velocity = Math.max(gestureVelocity, defaultVelocity);\n        const resetDuration = movedDistance / velocity;\n        const goBackDuration = (axisDistance - movedDistance) / velocity;\n\n        // To asyncronously get the current animated value, we need to run stopAnimation:\n        position.stopAnimation((value: number) => {\n          // If the speed of the gesture release is significant, use that as the indication\n          // of intent\n          if (gestureVelocity < -0.5) {\n            this._reset(immediateIndex, resetDuration);\n            return;\n          }\n          if (gestureVelocity > 0.5) {\n            this._goBack(immediateIndex, goBackDuration);\n            return;\n          }\n\n          // Then filter based on the distance the screen was moved. Over a third of the way swiped,\n          // and the back will happen.\n          if (value <= index - POSITION_THRESHOLD) {\n            this._goBack(immediateIndex, goBackDuration);\n          } else {\n            this._reset(immediateIndex, resetDuration);\n          }\n        });\n      },\n    });\n\n    const { options } = this._getScreenDetails(scene);\n    const gesturesEnabled = typeof options.gesturesEnabled === 'boolean'\n      ? options.gesturesEnabled\n      : Platform.OS === 'ios';\n\n    const handlers = gesturesEnabled ? responder.panHandlers : {};\n\n    return (\n      <View {...handlers} style={styles.container}>\n        <View style={styles.scenes}>\n          {scenes.map((s: *) => this._renderCard(s))}\n        </View>\n        {floatingHeader}\n      </View>\n    );\n  }\n\n  _getHeaderMode(): HeaderMode {\n    if (this.props.headerMode) {\n      return this.props.headerMode;\n    }\n    if (Platform.OS === 'android' || this.props.mode === 'modal') {\n      return 'screen';\n    }\n    return 'float';\n  }\n\n  _renderInnerScene(\n    SceneComponent: ReactClass<*>,\n    scene: NavigationScene\n  ): React.Element<any> {\n    const { navigation } = this._getScreenDetails(scene);\n    const { screenProps } = this.props;\n    const headerMode = this._getHeaderMode();\n    if (headerMode === 'screen') {\n      return (\n        <View style={styles.container}>\n          <View style={{ flex: 1 }}>\n            <SceneView\n              screenProps={screenProps}\n              navigation={navigation}\n              component={SceneComponent}\n            />\n          </View>\n          {this._renderHeader(scene, headerMode)}\n        </View>\n      );\n    }\n    return (\n      <SceneView\n        screenProps={this.props.screenProps}\n        navigation={navigation}\n        component={SceneComponent}\n      />\n    );\n  }\n\n  _renderCard = (scene: NavigationScene): React.Element<*> => {\n    const isModal = this.props.mode === 'modal';\n\n    /* $FlowFixMe */\n    const { screenInterpolator } = TransitionConfigs.getTransitionConfig(\n      this.props.transitionConfig,\n      {},\n      {},\n      isModal\n    );\n    const style =\n      screenInterpolator && screenInterpolator({ ...this.props, scene });\n\n    const SceneComponent = this.props.router.getComponentForRouteName(\n      scene.route.routeName\n    );\n\n    return (\n      <Card\n        {...this.props}\n        key={`card_${scene.key}`}\n        style={[style, this.props.cardStyle]}\n        scene={scene}\n      >\n        {this._renderInnerScene(SceneComponent, scene)}\n      </Card>\n    );\n  };\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    // Header is physically rendered after scenes so that Header won't be\n    // covered by the shadows of the scenes.\n    // That said, we'd have use `flexDirection: 'column-reverse'` to move\n    // Header above the scenes.\n    flexDirection: 'column-reverse',\n  },\n  scenes: {\n    flex: 1,\n  },\n});\n\nexport default CardStack;\n"]}]