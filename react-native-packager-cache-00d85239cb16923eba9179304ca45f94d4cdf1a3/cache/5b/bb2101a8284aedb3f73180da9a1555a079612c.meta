["fd8e5f0ba6df05bf5016f26eeb95bfb1fcb97598","3e5584e2beb395aca994c1a5fcad3c4565a91685",[],[],{"version":3,"sources":["/home/ziddi/Desktop/venders/node_modules/linked-list/_source/linked-list.js"],"names":["errorMessage","List","arguments","length","from","ListPrototype","prototype","of","call","items","list","iterator","item","undefined","append","head","tail","toArray","result","push","next","prepend","detach","Error","self","ListItem","Item","ListItemPrototype","prev","module","exports"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Constants.\n */\n\nvar errorMessage;\n\nerrorMessage = 'An argument without append, prepend, ' +\n    'or detach methods was given to `List';\n\n/**\n * Creates a new List: A linked list is a bit like an Array, but\n * knows nothing about how many items are in it, and knows only about its\n * first (`head`) and last (`tail`) items. Each item (e.g. `head`, `tail`,\n * &c.) knows which item comes before or after it (its more like the\n * implementation of the DOM in JavaScript).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of List.\n */\n\nfunction List(/*items...*/) {\n    if (arguments.length) {\n        return List.from(arguments);\n    }\n}\n\nvar ListPrototype;\n\nListPrototype = List.prototype;\n\n/**\n * Creates a new list from the arguments (each a list item) passed in.\n * @name List.of\n * @param {...ListItem} [items] - Zero or more items to attach.\n * @returns {list} - A new instance of List.\n */\n\nList.of = function (/*items...*/) {\n    return List.from.call(this, arguments);\n};\n\n/**\n * Creates a new list from the given array-like object (each a list item)\n * passed in.\n * @name List.from\n * @param {ListItem[]} [items] - The items to append.\n * @returns {list} - A new instance of List.\n */\nList.from = function (items) {\n    var list = new this(), length, iterator, item;\n\n    if (items && (length = items.length)) {\n        iterator = -1;\n\n        while (++iterator < length) {\n            item = items[iterator];\n\n            if (item !== null && item !== undefined) {\n                list.append(item);\n            }\n        }\n    }\n\n    return list;\n};\n\n/**\n * List#head\n * Default to `null`.\n */\nListPrototype.head = null;\n\n/**\n * List#tail\n * Default to `null`.\n */\nListPrototype.tail = null;\n\n/**\n * Returns the list's items as an array. This does *not* detach the items.\n * @name List#toArray\n * @returns {ListItem[]} - An array of (still attached) ListItems.\n */\nListPrototype.toArray = function () {\n    var item = this.head,\n        result = [];\n\n    while (item) {\n        result.push(item);\n        item = item.next;\n    }\n\n    return result;\n};\n\n/**\n * Prepends the given item to the list: Item will be the new first item\n * (`head`).\n * @name List#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\nListPrototype.prepend = function (item) {\n    if (!item) {\n        return false;\n    }\n\n    if (!item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + '#prepend`.');\n    }\n\n    var self, head;\n\n    // Cache self.\n    self = this;\n\n    // If self has a first item, defer prepend to the first items prepend\n    // method, and return the result.\n    head = self.head;\n\n    if (head) {\n        return head.prepend(item);\n    }\n\n    // ...otherwise, there is no `head` (or `tail`) item yet.\n\n    // Detach the prependee.\n    item.detach();\n\n    // Set the prependees parent list to reference self.\n    item.list = self;\n\n    // Set self's first item to the prependee, and return the item.\n    self.head = item;\n\n    return item;\n};\n\n/**\n * Appends the given item to the list: Item will be the new last item (`tail`)\n * if the list had a first item, and its first item (`head`) otherwise.\n * @name List#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - An instance of ListItem (the given item).\n */\n\nListPrototype.append = function (item) {\n    if (!item) {\n        return false;\n    }\n\n    if (!item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + '#append`.');\n    }\n\n    var self, head, tail;\n\n    // Cache self.\n    self = this;\n\n    // If self has a last item, defer appending to the last items append\n    // method, and return the result.\n    tail = self.tail;\n\n    if (tail) {\n        return tail.append(item);\n    }\n\n    // If self has a first item, defer appending to the first items append\n    // method, and return the result.\n    head = self.head;\n\n    if (head) {\n        return head.append(item);\n    }\n\n    // ...otherwise, there is no `tail` or `head` item yet.\n\n    // Detach the appendee.\n    item.detach();\n\n    // Set the appendees parent list to reference self.\n    item.list = self;\n\n    // Set self's first item to the appendee, and return the item.\n    self.head = item;\n\n    return item;\n};\n\n/**\n * Creates a new ListItem: A linked list item is a bit like DOM node:\n * It knows only about its \"parent\" (`list`), the item before it (`prev`),\n * and the item after it (`next`).\n * @global\n * @private\n * @constructor\n * @class Represents an instance of ListItem.\n */\n\nfunction ListItem() {}\n\nList.Item = ListItem;\n\nvar ListItemPrototype = ListItem.prototype;\n\nListItemPrototype.next = null;\n\nListItemPrototype.prev = null;\n\nListItemPrototype.list = null;\n\n/**\n * Detaches the item operated on from its parent list.\n * @name ListItem#detach\n * @returns {ListItem} - The item operated on.\n */\nListItemPrototype.detach = function () {\n    // Cache self, the parent list, and the previous and next items.\n    var self = this,\n        list = self.list,\n        prev = self.prev,\n        next = self.next;\n\n    // If the item is already detached, return self.\n    if (!list) {\n        return self;\n    }\n\n    // If self is the last item in the parent list, link the lists last item\n    // to the previous item.\n    if (list.tail === self) {\n        list.tail = prev;\n    }\n\n    // If self is the first item in the parent list, link the lists first item\n    // to the next item.\n    if (list.head === self) {\n        list.head = next;\n    }\n\n    // If both the last and first items in the parent list are the same,\n    // remove the link to the last item.\n    if (list.tail === list.head) {\n        list.tail = null;\n    }\n\n    // If a previous item exists, link its next item to selfs next item.\n    if (prev) {\n        prev.next = next;\n    }\n\n    // If a next item exists, link its previous item to selfs previous item.\n    if (next) {\n        next.prev = prev;\n    }\n\n    // Remove links from self to both the next and previous items, and to the\n    // parent list.\n    self.prev = self.next = self.list = null;\n\n    // Return self.\n    return self;\n};\n\n/**\n * Prepends the given item *before* the item operated on.\n * @name ListItem#prepend\n * @param {ListItem} item - The item to prepend.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.prepend = function (item) {\n    if (!item || !item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + 'Item#prepend`.');\n    }\n\n    // Cache self, the parent list, and the previous item.\n    var self = this,\n        list = self.list,\n        prev = self.prev;\n\n    // If self is detached, return false.\n    if (!list) {\n        return false;\n    }\n\n    // Detach the prependee.\n    item.detach();\n\n    // If self has a previous item...\n    if (prev) {\n        // ...link the prependees previous item, to selfs previous item.\n        item.prev = prev;\n\n        // ...link the previous items next item, to self.\n        prev.next = item;\n    }\n\n    // Set the prependees next item to self.\n    item.next = self;\n\n    // Set the prependees parent list to selfs parent list.\n    item.list = list;\n\n    // Set the previous item of self to the prependee.\n    self.prev = item;\n\n    // If self is the first item in the parent list, link the lists first item\n    // to the prependee.\n    if (self === list.head) {\n        list.head = item;\n    }\n\n    // If the the parent list has no last item, link the lists last item to\n    // self.\n    if (!list.tail) {\n        list.tail = self;\n    }\n\n    // Return the prependee.\n    return item;\n};\n\n/**\n * Appends the given item *after* the item operated on.\n * @name ListItem#append\n * @param {ListItem} item - The item to append.\n * @returns {ListItem} - The item operated on, or false when that item is not\n * attached.\n */\nListItemPrototype.append = function (item) {\n    // If item is falsey, return false.\n    if (!item || !item.append || !item.prepend || !item.detach) {\n        throw new Error(errorMessage + 'Item#append`.');\n    }\n\n    // Cache self, the parent list, and the next item.\n    var self = this,\n        list = self.list,\n        next = self.next;\n\n    // If self is detached, return false.\n    if (!list) {\n        return false;\n    }\n\n    // Detach the appendee.\n    item.detach();\n\n    // If self has a next item...\n    if (next) {\n        // ...link the appendees next item, to selfs next item.\n        item.next = next;\n\n        // ...link the next items previous item, to the appendee.\n        next.prev = item;\n    }\n\n    // Set the appendees previous item to self.\n    item.prev = self;\n\n    // Set the appendees parent list to selfs parent list.\n    item.list = list;\n\n    // Set the next item of self to the appendee.\n    self.next = item;\n\n    // If the the parent list has no last item or if self is the parent lists\n    // last item, link the lists last item to the appendee.\n    if (self === list.tail || !list.tail) {\n        list.tail = item;\n    }\n\n    // Return the appendee.\n    return item;\n};\n\n/**\n * Expose `List`.\n */\n\nmodule.exports = List;\n"]}]