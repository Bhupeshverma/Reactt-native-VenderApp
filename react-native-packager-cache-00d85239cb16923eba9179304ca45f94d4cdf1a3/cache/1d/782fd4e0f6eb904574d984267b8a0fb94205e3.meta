["f22ef2cfdfda91c97ec69f6a47d9e978f2809beb","0ce060bbdf2ce6ec1bf8b0e8175cd2e633ad0ad0",["lodash"],[143],{"version":3,"sources":["/home/ziddi/Desktop/venders/node_modules/@shoutem/theme/src/resolveComponentStyle.js"],"names":["resolveComponentStyle","styleVariantRegex","RegExp","childStyleRegex","isStyleVariant","propertyName","test","isChildStyle","splitStyle","style","reduce","result","value","key","styleSection","componentStyle","styleVariants","childrenStyle","componentName","styleNames","themeStyle","parentStyle","elementStyle","mergedStyle","merge","map","sn","resolvedStyle"],"mappings":";;;QAmFgBA,qB,GAAAA,qB;;AAnFhB;;;;AAEA,IAAMC,oBAAoB,IAAIC,MAAJ,CAAW,MAAX,CAA1B;AACA,IAAMC,kBAAkB,IAAID,MAAJ,CAAW,sBAAX,CAAxB;;AAWA,SAASE,cAAT,CAAwBC,YAAxB,EAAsC;AACpC,SAAOJ,kBAAkBK,IAAlB,CAAuBD,YAAvB,CAAP;AACD;;AAcD,SAASE,YAAT,CAAsBF,YAAtB,EAAoC;AAClC,SAAOF,gBAAgBG,IAAhB,CAAqBD,YAArB,CAAP;AACD;;AAWD,SAASG,UAAT,CAAoBC,KAApB,EAA2B;AACzB,SAAO,iBAAEC,MAAF,CAASD,KAAT,EAAgB,UAACE,MAAD,EAASC,KAAT,EAAgBC,GAAhB,EAAwB;AAC7C,QAAIC,eAAeH,OAAOI,cAA1B;AACA,QAAIX,eAAeS,GAAf,CAAJ,EAAyB;AACvBC,qBAAeH,OAAOK,aAAtB;AACD,KAFD,MAEO,IAAIT,aAAaM,GAAb,CAAJ,EAAuB;AAC5BC,qBAAeH,OAAOM,aAAtB;AACD;AACDH,iBAAaD,GAAb,IAAoBD,KAApB;AACA,WAAOD,MAAP;AACD,GATM,EASJ;AACDI,oBAAgB,EADf;AAEDC,mBAAe,EAFd;AAGDC,mBAAe;AAHd,GATI,CAAP;AAcD;;AAyBM,SAASjB,qBAAT,CACLkB,aADK,EAML;AAAA,MAJAC,UAIA,uEAJa,EAIb;AAAA,MAHAC,UAGA,uEAHa,EAGb;AAAA,MAFAC,WAEA,uEAFc,EAEd;AAAA,MADAC,YACA,uEADe,EACf;;AAMA,MAAMC,cAAc,iBAAEC,KAAF,0BAAQ,EAAR,EAClBJ,UADkB,EAElBC,YAAY,GAAZ,CAFkB,EAGlBA,YAAYH,aAAZ,CAHkB,wCAIf,iBAAEO,GAAF,CAAMN,UAAN,EAAkB,UAACO,EAAD;AAAA,WAAQN,iBAAeM,EAAf,CAAR;AAAA,GAAlB,CAJe,kCAKf,iBAAED,GAAF,CAAMN,UAAN,EAAkB,UAACO,EAAD;AAAA,WAAQL,mBAAiBK,EAAjB,CAAR;AAAA,GAAlB,CALe,kCAMf,iBAAED,GAAF,CAAMN,UAAN,EAAkB,UAACO,EAAD;AAAA,WAAQL,YAAeH,aAAf,SAAgCQ,EAAhC,CAAR;AAAA,GAAlB,CANe,IAOlBJ,YAPkB,GAApB;;AAaA,MAAMK,gBAAgB,iBAAEH,KAAF,0BAAQ,EAAR,EACpBD,WADoB,EAEpBF,YAAY,GAAZ,CAFoB,EAGpBA,YAAYH,aAAZ,CAHoB,wCAIjB,iBAAEO,GAAF,CAAMN,UAAN,EAAkB,UAACO,EAAD;AAAA,WAAQH,kBAAgBG,EAAhB,CAAR;AAAA,GAAlB,CAJiB,kCAKjB,iBAAED,GAAF,CAAMN,UAAN,EAAkB,UAACO,EAAD;AAAA,WAAQL,mBAAiBK,EAAjB,CAAR;AAAA,GAAlB,CALiB,kCAMjB,iBAAED,GAAF,CAAMN,UAAN,EAAkB,UAACO,EAAD;AAAA,WAAQL,YAAeH,aAAf,SAAgCQ,EAAhC,CAAR;AAAA,GAAlB,CANiB,IAOpBJ,YAPoB,GAAtB;;AAnBA,oBA6B0Cd,WAAWmB,aAAX,CA7B1C;AAAA,MA6BQZ,cA7BR,eA6BQA,cA7BR;AAAA,MA6BwBE,aA7BxB,eA6BwBA,aA7BxB;;AA+BA,SAAO;AACLF,kCADK;AAELE;AAFK,GAAP;AAID","sourcesContent":["import _ from 'lodash';\n\nconst styleVariantRegex = new RegExp('^\\\\.');\nconst childStyleRegex = new RegExp('(^[^\\\\.].*\\\\.)|^\\\\*$');\n\n/**\n * Matches any style properties that represent component style variants.\n * Those styles can be applied to the component by using the styleName\n * prop. All style variant property names must start with a single '.'\n * character, e.g., '.variant'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a component variant, false otherwise.\n */\nfunction isStyleVariant(propertyName) {\n  return styleVariantRegex.test(propertyName);\n}\n\n/**\n * Matches any style properties that represent style rules that target the\n * component children. Those styles can have two formats, they can either\n * target the components by component name ('shoutem.ui.Text'), or by component\n * name and variant ('shoutem.ui.Text.line-through'). Beside specifying the\n * component name, those styles can also target any component by using the\n * '*' wildcard ('*', or '*.line-through'). The rule to identify those styles is\n * that they have to contain a '.' character in their name or be a '*'.\n *\n * @param propertyName The style property name.\n * @returns {boolean} True if the style property represents a child style, false otherwise.\n */\nfunction isChildStyle(propertyName) {\n  return childStyleRegex.test(propertyName);\n}\n\n/**\n * Splits the style into its parts:\n * component style - concrete style that needs to be applied to a component\n * style variants - variants that can be applied to a component by using styleName prop\n * children style - style rules that need to be propagated to component children\n *\n * @param style The style to split.\n * @returns {*} An object with the componentStyle, styleVariants, and childrenStyle keys.\n */\nfunction splitStyle(style) {\n  return _.reduce(style, (result, value, key) => {\n    let styleSection = result.componentStyle;\n    if (isStyleVariant(key)) {\n      styleSection = result.styleVariants;\n    } else if (isChildStyle(key)) {\n      styleSection = result.childrenStyle;\n    }\n    styleSection[key] = value;\n    return result;\n  }, {\n    componentStyle: {},\n    styleVariants: {},\n    childrenStyle: {},\n  });\n}\n\n/**\n * Resolves the final component style by merging all of the styles that can be\n * applied to a component in the proper order.\n *\n * This function extracts the applicable parts of the theme, parent and element\n * styles, and merges the styles that target the component, and component variants\n * with those styles to get the final style.\n *\n * The styles are merged in the following order, where the styles with the\n * higher index override the styles with the lower one:\n * 1. Theme component style\n * 2. Parent component style\n * 3. Theme style variants specified through styleName\n * 4. Parent style variants specified through styleName\n * 5. Element style passed through the style prop\n *\n * @param componentName The component name ('shoutem.ui.Text')\n * @param styleNames Style names ('large rounded')\n * @param themeStyle The theme style that should include the theme and base component style\n * @param parentStyle The style rules inherited from the parent component\n * @param elementStyle The style passed through the style prop of the component\n * @returns {{componentStyle, childrenStyle}} The resolved component and children styles.\n */\nexport function resolveComponentStyle(\n  componentName,\n  styleNames = [],\n  themeStyle = {},\n  parentStyle = {},\n  elementStyle = {}\n) {\n  // Phase 1: merge the styles in the correct order to resolve the variant styles,\n  // the component style will be merged as well in this step, but the component\n  // style merge results are ignored after this step. We need to perform this\n  // step separately because the style variants may be overridden by any style, so\n  // the purpose of this phase is to determine the final state of the variant styles.\n  const mergedStyle = _.merge({},\n    themeStyle,\n    parentStyle['*'],\n    parentStyle[componentName],\n    ..._.map(styleNames, (sn) => themeStyle[`.${sn}`]),\n    ..._.map(styleNames, (sn) => parentStyle[`*.${sn}`]),\n    ..._.map(styleNames, (sn) => parentStyle[`${componentName}.${sn}`]),\n    elementStyle\n  );\n\n  // Phase 2: merge the component styles, this step is performed by using the\n  // style from phase 1, so that we are sure that the final style variants are\n  // applied to component style.\n  const resolvedStyle = _.merge({},\n    mergedStyle,\n    parentStyle['*'],\n    parentStyle[componentName],\n    ..._.map(styleNames, (sn) => mergedStyle[`.${sn}`]),\n    ..._.map(styleNames, (sn) => parentStyle[`*.${sn}`]),\n    ..._.map(styleNames, (sn) => parentStyle[`${componentName}.${sn}`]),\n    elementStyle\n  );\n\n  const { componentStyle, childrenStyle } = splitStyle(resolvedStyle);\n\n  return {\n    componentStyle,\n    childrenStyle,\n  };\n}\n"]}]